" ___vital___
" NOTE: lines between '" ___vital___' is generated by :Vitalize.
" Do not mofidify the code nor insert new lines before '" ___vital___'
if v:version > 703 || v:version == 703 && has('patch1170')
  function! vital#_gina#Vim#Buffer#Anchor#import() abort
    return map({'focus': '', '_vital_depends': '', 'is_suitable': '', 'focus_if_available': '', '_vital_created': '', 'find_suitable': '', 'get_config': '', 'set_config': '', 'is_available': '', 'attach': '', '_vital_loaded': ''},  'function("s:" . v:key)')
  endfunction
else
  function! s:_SID() abort
    return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
  endfunction
  execute join(['function! vital#_gina#Vim#Buffer#Anchor#import() abort', printf("return map({'focus': '', '_vital_depends': '', 'is_suitable': '', 'focus_if_available': '', '_vital_created': '', 'find_suitable': '', 'get_config': '', 'set_config': '', 'is_available': '', 'attach': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
  delfunction s:_SID
endif
" ___vital___
let s:save_cpo = &cpo
set cpo&vim

" An unique identifier for autocmd definition
let s:UNIQUE = sha256(expand('<sfile>:p'))

function! s:_vital_loaded(V) abort
  let s:Dict = a:V.import('Data.Dict')
endfunction

function! s:_vital_depends() abort
  return ['Data.Dict']
endfunction

function! s:_vital_created(module) abort
  let a:module.disallow_preview = 0
  let a:module.buflisted_required = 1
  let a:module.unsuitable_buftype_pattern = '^\%(nofile\|quickfix\)$'
  let a:module.unsuitable_bufname_pattern = ''
  let a:module.unsuitable_filetype_pattern = ''
  let s:module = a:module
endfunction

function! s:get_config() abort dict
  return s:Dict.pick(self, [
        \ 'disallow_preview',
        \ 'buflisted_required',
        \ 'unsuitable_buftype_pattern',
        \ 'unsuitable_bufname_pattern',
        \ 'unsuitable_filetype_pattern',
        \])
endfunction

function! s:set_config(config) abort dict
  call extend(self, s:Dict.pick(a:config, [
        \ 'disallow_preview',
        \ 'buflisted_required',
        \ 'unsuitable_buftype_pattern',
        \ 'unsuitable_bufname_pattern',
        \ 'unsuitable_filetype_pattern',
        \]))
endfunction

function! s:is_available(opener) abort
  if a:opener =~# '\<p\%[tag]!\?\>'
    return 0
  elseif a:opener =~# '\<ped\%[it]!\?\>'
    return 0
  elseif a:opener =~# '\<ps\%[earch]!\?\>'
    return 0
  elseif a:opener =~# '\<\%(tabe\%[dit]\|tabnew\)\>'
    return 0
  elseif a:opener =~# '\<tabf\%[ind]\>'
    return 0
  endif
  return 1
endfunction

function! s:is_suitable(winnum) abort dict
  let bufnum  = winbufnr(a:winnum)
  if empty(bufname(bufnum))
    return 1
  elseif self.disallow_preview && &previewwindow
    return 0
  elseif self.buflisted_required && !buflisted(bufnum)
    return 0
  elseif !empty(self.unsuitable_bufname_pattern)
        \ && bufname(bufnum) =~# self.unsuitable_bufname_pattern
    return 0
  elseif !empty(self.unsuitable_buftype_pattern)
        \ && getbufvar(bufnum, '&buftype') =~# self.unsuitable_buftype_pattern
    return 0
  elseif !empty(self.unsuitable_filetype_pattern)
        \ && getbufvar(bufnum, '&filetype') =~# self.unsuitable_filetype_pattern
    return 0
  endif
  return 1
endfunction

function! s:find_suitable(winnum, ...) abort dict
  let winnum = max([1, a:winnum])
  if winnr('$') == 1
    return 1
  endif
  let is_reverse = get(a:000, 0, 0)
  let rangeset = is_reverse
        \ ? [reverse(range(1, winnum)), reverse(range(winnum + 1, winnr('$')))]
        \ : [range(winnum, winnr('$')), range(1, winnum - 1)]
  " find a suitable window in rightbelow from a previous window
  for winnum in rangeset[0]
    if self.is_suitable(winnum)
      return winnum
    endif
  endfor
  " find a suitable window in leftabove to before a previous window
  for winnum in rangeset[1]
    if self.is_suitable(winnum)
      return winnum
    endif
  endfor
  " no suitable window is found.
  return 0
endfunction

function! s:focus(...) abort dict
  if self.is_suitable(winnr())
    return
  endif
  " find suitable window from the previous window
  let previous_winnum = winnr('#')
  let suitable_winnum = self.find_suitable(previous_winnum, get(a:000, 0, 0))
  let suitable_winnum = suitable_winnum == 0
        \ ? previous_winnum
        \ : suitable_winnum
  silent execute printf('keepjumps %dwincmd w', suitable_winnum)
endfunction

function! s:focus_if_available(opener, ...) abort dict
  if self.is_available(a:opener)
    call call('s:focus', a:000, self)
  endif
endfunction

function! s:attach() abort
  execute 'augroup vital_vim_buffer_anchor_attach_internal' s:UNIQUE
  execute 'autocmd! * <buffer>'
  execute 'autocmd WinLeave <buffer> call s:_on_WinLeave()'
  execute 'augroup END'
endfunction

function! s:_on_WinLeave() abort
  let s:_vital_vim_buffer_anchor_winleave = winnr('$')
endfunction

function! s:_on_WinEnter() abort
  if exists('s:_vital_vim_buffer_anchor_winleave')
    let nwin = s:_vital_vim_buffer_anchor_winleave
    if winnr('$') < nwin
      call call('s:focus', [1], s:module)
    endif
    unlet s:_vital_vim_buffer_anchor_winleave
  endif
endfunction

execute 'augroup vital_vim_buffer_anchor_internal' s:UNIQUE
execute 'autocmd! *'
execute 'autocmd WinEnter * call s:_on_WinEnter()'
execute 'augroup END'

let &cpo = s:save_cpo
unlet! s:save_cpo
